<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="ildoc.xml.css" type="text/css"?>
<ildoc xmlns="http://dzonny.cz/xml/ildoc" id="ildoc" guid="25e7bd25-3621-4b5b-bc3e-5f9b6ba848d4">
	<header>CIL Quick referecne</header>
	<introduction>
		This guide describes various low-level parts of .NET framework.
		Big attension is given to Common Inermediate Language syntax, metadata and instruction-set.
	</introduction>
    <!--Formatting-->
	<formatting id="formatting" guid="0bf4d96b-2001-4d76-b7dc-511a1b3810e2">
		<header>Formatting and regular expressions</header>
		<introduction>This section describes formatting and regular expressions (syntax grammar) used in this CLI Quick reference guide.</introduction>
		<dl>
			<dt-code>Code</dt-code>
			<dd>Code is anything that originates from the CIL language including regular expressions (syntax definitions) and .NET type names.</dd>
            <dt-code-ref>Reference in code</dt-code-ref>
			<dd>
				This is used in regular expressions (syntax definitions) to mark element (terminal or non-terminal) being declared elsewhere.
				It is also used to mark variables explained immediatelly below.
			</dd>
            <dt>note reference</dt>
			<dd>
				Reference to note is never formated as code.
				This way it is possible to distinguish when asterisk (*) is part of regular expression and when it is reference to note.
				Compare <code>*</code> and *.
			</dd>
			<dt>Regular expressions</dt>
			<dd>
				Regular expressions for syntax definitions are losely based on .NET reguler expressions and grammar used for CLI grammas pecification.
				These expressions are not meant to be machine-readable, so some improvements towards human readability have been done possibly preventing those expressions from beingin machine-interpretable or unambignously defined.
			</dd>
			<dd>
				Any text which appears in regular expression is treated as string-literal (as-is) with exception of <code>*</code>, <code>+</code>, <code>?</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>\</code>, <code>|</code>.
				Dot (<code>.</code>) is treated as special character only when followed by <code>*</code>, <code>?</code>, <code>+</code> or <code>{</code> or inside <code>[]</code>.
				<code>{</code> and <code>}</code> are treated as special characters only if used as specified below.
				<code>,</code>, <code>-</code> and <code>^</code> are treated as special character only in contexts specified below.
				Whitespaces in expressions are ignored or not depending on context. Usually sequnce of whitespaces is treated as any number opf any whitespaces. Sometimes whitespaces can be used instead of braces - see below.
			</dd>
			<dl>
				<dt-code>*</dt-code>
				<dd>Any number of occurences</dd>
				<dd><code>a*</code> matches <code>''</code>, <code>'a'</code>, <code>'aa'</code>, <code>'aaa'</code> etc.</dd>
				<dt-code>+</dt-code>
				<dd>Any number of occurences other than no occurence.</dd>
				<dd><code>a+</code> matches <code>'a'</code>, <code>'aa'</code>, <code>'aaa'</code> etc.</dd>
				<dt-code>?</dt-code>
				<dd>Zero or one occurence</dd>
				<dd><code>a?</code> matches <code>''</code> and <code>'a'</code></dd>
				<dt-code>{<ref>n</ref>}</dt-code>
				<dd>Exactly <code-ref>n</code-ref> occurences</dd>
				<dd><code>a{3}</code> matches <code>'aaa'</code></dd>
				<dt-code>{<ref>m</ref>,<ref>n</ref>}</dt-code>
				<dd>Mininally <code-ref>m</code-ref>, maximally <code-ref>n</code-ref> occurences</dd>
				<dd><code>a{1,3}</code> matches <code>'a'</code>, <code>'aa'</code> and <code>'aaa'</code></dd>
				<dt-code>{}</dt-code>
				<dd>Matches block of CIL code enclosed in <code>{}</code>. Allowd code in block is specified in this guide.</dd>
				<dt-code>{|}</dt-code>
				<dd>Flag-or. One or more elements of set can be used any any order without repetitions.</dd>
				<dd><code>{a|b|c}</code> matches <code>''</code>, <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'ab'</code>, <code>'ba'</code>, <code>'ac'</code>, <code>'ca'</code>, <code>'bc'</code>, <code>'cb'</code>, <code>'abc'</code>, <code>'acb'</code>, <code>'bac'</code>, <code>'cab'</code>, <code>'cba'</code>.</dd>
				<dt-code>()</dt-code>
				<dd>Classical braces</dd>
				<dd><code>(ab)+</code> matches <code>'ab'</code>, <code>'abab'</code> etc.</dd>
				<dt-code>[]</dt-code>
				<dd>More meanings:</dd>
				<dl>
					<dt>Group specifier</dt>
					<dd>Trated this way only when cointains not-escaped <code>-</code> and does not contain not-escaped <code>|</code>.</dd>
					<dd>Inside group specifier only <code>-</code>, <code>]</code>, <code>|</code> and <code>^</code> are treated as special characters.</dd>
					<dd><code>[A-Zů]</code> matches <code>'A'</code>, <code>'B'</code>, <code>'C'</code>, ..., <code>'Z'</code> and <code>'ů'</code>.</dd>
					<dd><code>[A-Z]+</code> matches <code>'A'</code>, <code>'B'</code>, <code>'AB'</code>, <code>'GAG'</code>, <code>'HUIGG'</code>.</dd>
					<dt>Inverted group specifier</dt>
					<dd>
						In case <code>[</code> is immediatelly followed by <code>^</code>.
						Does not have to contain not-escaped <code>-</code> and can contain not-escaped <code>|</code>.
						Only <code>-</code>, <code>]</code> and <code>^</code> are treated as special-characters inside inverted group specifier.
					</dd>
					<dd><code>[^c-ek]</code> does <b>not</b> match <code>'c'</code>, <code>'d'</code>, <code>'e'</code>, <code>'k'</code>.</dd>
					<dt>Normal braces (just like <code>()</code>)</dt>
					<dd>In case it does not contain not-escaped <code>-</code>, does not begin with <code>^</code> and is followed by one of quantifiers <code>*</code>, <code>+</code>, <code>?</code>, <code>{}</code>.</dd>
					<dd><code>[a]*</code> matches <code>''</code>, <code>'a'</code>, <code>'aa'</code> etc.</dd>
					<dt>Or</dt>
					<dd>In case it does not start with <code>^</code> and contains non-escaped <code>|</code>.</dd>
					<dd>
						Note that usage of <code>|</code> inside <code>[]</code> slightly differs from its usage outside it or inside <code>()</code>.
						In <code>[]</code> it behaves like if it has whitespace on both sides even if it does not have them.
					</dd>
					<dd>
						<code>[aaa|bbb]</code> has same meaning as <code>(aaa | bbb)</code> what has same meaning as <code>((aaa)|(bbb))</code> and it has same meaning as <code>[aaa | bbb]</code>.
						It matches <code>'aaa'</code> or <code>'bbb'</code>.
					</dd>
					<dt>Zero or one occurence quantifier</dt>
					<dd>In all other cases</dd>
					<dd><code>[ab]</code> matches <code>''</code> or <code>'ab'</code>.</dd>
				</dl>
				<dt-code>\</dt-code>
				<dd>Escape character</dd>
				<dd><code>\*</code> matches <code>'*'</code>, <code>\\</code> matches <code>\</code>, <code>\a</code> matches <code>a</code></dd>
				<dt-code>.</dt-code>
				<dd>Universal character - matches any single character, but onyl when followed by one of quantifiers <code>*</code>, <code>?</code>, <code>+</code> or <code>{}</code>.</dd>
				<dd><code>.?</code> matches <code>''</code>, <code>'.'</code>, <code>'a'</code>, <code>'Ω'</code> etc.</dd>
				<dt-code>|</dt-code>
				<dd>Or - matches contruct on left side or construct on right side.</dd>
				<dd>When specified withoud whitespaces minimal contruct on side without whitespace is taken (typically one letter).</dd>
				<dd>
                    When specified with whitespace maximal construct on site eith whitespace is take.
                    Maximal construct lookup is broken only by reaching scope boundary from inside at same level where <code>|</code> was used.
                    Scope boundaries are introduced by whole expression itself, <code>()</code>, <code>[]</code> and <code>{|}</code> but <code>{|}</code> is irrelevant because <code>|</code> inside <code>{}</code> has slightly different meaning.
                </dd>
				<dd>Note that inside <code>[]</code> <code>|</code> has different behavior (regarding whitespaces around it) then when not in <code>[]</code> - inside <code>[]</code> it always behaves like having whitespace on each side.</dd>
				<dd><code>bye|hi</code> matches <code>'byei'</code> or <code>'byhi'</code>.</dd>
				<dd><code>bye | hi</code> matches <code>'bye'</code> or <code>'hi'</code>.</dd>
			</dl>
		</dl>
	</formatting>
    <!--Terms-->
    <section id="terms" guid="769c30f5-a581-4199-b99a-4cb64860af64">
        <header>Terms</header>
        <introduction>This section describes common terms and abbreviations used in connection with .NET Framework.</introduction>
        <dl>
            <dt r="I.5">CIL</dt>
            <dt>Common Intermediate Language</dt>
            <dd>The instruction set understood by the VES.</dd>
            <dt r="I.5">CLI</dt>
            <dt>Common Language Infrastructure</dt>
            <dd>A specification for the format of executable code and runtime environment that can execute the code.</dd>
            <dt r="I.5">CLS</dt>
            <dt>Common Language Specification</dt>
            <dt>An agreement between language designers and framework (class library) designers. It specifies subset of the CTS and set of usage conventions.</dt>
            <dt r="I.5">CTS</dt>
            <dt>Common Type Systme</dt>
            <dd>
                A unified type system that is shared by compilers, tools, and the CLI itself. It
                is the model that defines the rules the CLI follows when declaring, using, and managing types. The CTS
                establishes a framework that enables cross-language integration, type safety, and high performance code
                execution.
            </dd>
            <dt r="I.5">VES</dt>
            <dt>Virtual Execution System</dt>
            <dd>
                This system implements and enforces the CTS model. The VES is
                responsible for loading and running programs written for the CLI. It provides the services needed to execute
                managed code and data using the metadata to connect separately generated modules together at runtime. The
                VES is also known as the Execution Engine.
            </dd>
        </dl>
    </section>
    <!--General syntax-->
	<section id="general-syntax" guid="630e459c-215c-4ee8-9015-f1ca5356751b">
		<header>General syntactical constructs</header>
		<introduction>This section describes syntactical elements used in CIL code.</introduction>
		<dl>
			<dt-ref id="Int32" r="II.5.2">Int32</dt-ref>
			<dt-ref id="Int64" r="II.5.2">Int64</dt-ref>
			<dd><code>([+|-][0-9]+)|(0x[0-9A-Fa-f]+)</code></dd>
			<dd>Inegral number in decimal or hexadecimal format. CIL recognizes only 32-bit and 64-bit integral literals. In case 8-bit or 16-bit literal is required, appropriate high part of 32-bit literal is used.</dd>
			<dt-ref id="RealNumber" r="II.5.2">RealNumber</dt-ref>
			<dd><code>[+|-]([0-9]+\.[0-9]+)|([0-9]+(E|e)[0-9]+)|([0-9]+\.[0-9]+(E|e)[+|-]][0-9]+)</code></dd>
			<dd>Real number literal differes from integer literal by having decimal point and/or exponent.</dd>
			<dt-ref id="Float32">Float32</dt-ref>
			<dt-ref id="Float64">Float64</dt-ref>
			<dd><code><ref ref="RealNumber">RealNumber</ref> | float32 \(<ref ref="Int32">Int32</ref>\) | \(<ref ref="Bytes">Bytes</ref>\)</code></dd>
			<dd><code><ref ref="RealNumber">RealNumber</ref> | float64 \(<ref ref="Int32">Int64</ref>\) | \(<ref ref="Bytes">Bytes</ref>\)</code></dd>
			<dd>
				Additionally real number can by entered by static cast from integral number or by byte representation.
				Byte representation is useful for values NaN, +∞ and -∞ when ilasm implementation does not support entering <code>NaN</code>, <code>Inf</code> and <code>-Inf</code> directly.
			</dd>
			<break/>
            <dt-ref id="QSTRING" r="II.5.2">QSTRING</dt-ref>
            <dd><code>"([^"] | \\")*"</code></dd>
            <dd>String value in double quotes (<code>"</code>). Exact behavior of excape character <code>\</code> is implementation-dependent. Used for string literals.</dd>
            <dt-ref id="SQSTRING" r="II.5.2">SQSTRING</dt-ref>
            <dd><code>'([^'] | \\')*'</code></dd>
            <dd>String value in single quotes (<code>'</code>). Exact behavior of escape character <code>\</code> is implementation dependent. Used for indentifiers containign special characters.</dd>
            <dt-ref id="ID" r="II.5.2">ID</dt-ref>
            <dd><code>[A-Za-z_$@`?][A-Za-z_$@`?0-9]*</code></dd>
            <dd>Identifier without special characters. <code>_</code>, <code>$</code>, <code>@</code>, <code>`</code> and <code>@</code> are not considered special characters.</dd>
            <dt-ref id="Id" r="II.5.3">Id</dt-ref>
            <dd><code><ref ref="ID">ID</ref> | <ref ref="SQSTRING">SQSTRING</ref></code></dd>
            <dd>Identifier can be either <ref ref="ID">ID</ref> or <ref ref="SQSTRING">SQSTRING</ref>.</dd>
            <dt-ref id="DottedName" r="II.5.3">DottedName</dt-ref>
            <dd><code><ref ref="Id">Id</ref>[.<ref ref="Id">Id</ref>]*</code></dd>
            <dd>Syntactical shortcut allowing to use names containing dots (<code>.</code>) without single quotes (<code>'</code>).</dd>
            <break/>
            <dt-ref id="HexByte" r="II.5.2">HexByte</dt-ref>
            <dd><code>[0-9A-Fa-f]{2}</code></dd>
            <dd>One byte represented by hexadecimal number (without leading hexa-specifier)</dd>
            <dt-ref id="Bytes" r="II.5.5">Bytes</dt-ref>
            <dd><code><ref ref="HexByte">HexByte</ref> [<ref ref="HexByte">HexByte</ref>]*</code></dd>
            <dd>Byte array is list of hexadecimally writtent bytes seperated by spaces.</dd>
            <break/>
            <dt r="II.10.1.7"><ref ref="GenPar">GenPar</ref></dt>
            <dd><code>{+|-|class|valuetype|.ctor} [\(<ref ref="Type">Type</ref> [, <ref ref="Type">Type</ref>]*\)] <ref ref="Id">Id</ref></code></dd>
            <dd>Generic parameter specification</dd>
            <dt r="II.7.1"><ref ref="TypeSpec">TypeSpec</ref></dt>
            <dd><code>\[[.module] <ref ref="DottedName">DottedName</ref>\] | <ref ref="TypeReference">TypeReference</ref> | <ref ref="Type">Type</ref></code></dd>
            <dd>Simplified reference to type. E.g. allows use <code>System.GC</code> instead of <code>.class System.GC</code></dd>
            <dt r="II.7.3"><ref ref="TypeReference">TypeReference</ref></dt>
            <dd><code>(\[.module <ref ref="DottedName">DottedName</ref>\] | \[<ref ref="DottedName">DottedName</ref>\]) <ref ref="DottedName">DottedName</ref> [/ <ref ref="DottedName">DottedName</ref>]*</code></dd>
            <dd>Reference to user-defined type</dd>
            <dt r="II.7.1"><ref ref="Type">Type</ref></dt>
            <dd>
                <code>
                    !<ref ref="Int32">Int32</ref> | !!<ref ref="Int32">Int32</ref> | bool | char |
                    class <ref ref="TypeReference">TypeReference</ref> |
                    floa32 | float64 | int8 | int16 | int32 | int64 |
                    method <ref ref="CallConv">CallConv</ref> <ref ref="Type">Type</ref> \* \([<ref ref="Param">Param</ref> [, <ref ref="Param">Param</ref>]*]\) |
                    native int | native unsigned int | object | string | <ref ref="Type">Type</ref>&amp; | <ref ref="Type">Type</ref>\* |
                    <ref ref="Type">Type</ref>&lt;<ref ref="Type">Type</ref> [, <ref ref="Type">Type</ref>]* [,]*> |
                    <ref ref="Type">Type</ref> \[[(... | <ref ref="Int32">Int32</ref> | <ref ref="Int32">Int32</ref> ... | <ref ref="Int32">Int32</ref> ... <ref ref="Int32">Int32</ref>) [, (... | <ref ref="Int32">Int32</ref> | <ref ref="Int32">Int32</ref> ... | <ref ref="Int32">Int32</ref> ... <ref ref="Int32">Int32</ref>)]*]\] |
                    <ref ref="Type">Type</ref> modopt \(<ref ref="TypeReference">TypeReference</ref>\) | <ref ref="Type">Type</ref> modreq \(<ref ref="TypeReference">TypeReference</ref>\) |
                    <ref ref="Type">Type</ref> pinned | typedref | valuetype <ref ref="TypeReference">TypeReference</ref> |
                    unsigned int8 | unsigned int16 | unsigned int32 | unsigned int64 | void
                </code>
            </dd>
            <dd>Complex type reference</dd>
            <dt r="II.7.4"><ref ref="NativeType">NativeType</ref></dt>
            <dd>
                <code>
                    \[\] | bool | float32 | float64 | [unsigned] int | [unsigned] int8 | [unsigned] int16 | [unsigned] int32 | [unsigned] int64 | lpstr | lpwstr | method |
                    <ref ref="NativeType">NativeType</ref> \[\] | <ref ref="NativeType">NativeType</ref>\[<ref ref="Int32">Int32</ref>\] | 
                    <ref ref="NativeType">NativeType</ref> \[\+ <ref ref="Int32">Int32</ref>\] | <ref ref="NativeType">NativeType</ref> \[<ref ref="Int32">Int32</ref> \+ <ref ref="Int32">Int32</ref>\] |
                    <ms-specific>
                        (as any | byvalstr | custom \(<ref ref="QSTRING">QSTRING</ref>,<ref ref="QSTRING">QSTRING</ref>\) | fixed array [<ref ref="Int32">Int32</ref>] | fixed sysstring [<ref ref="Int32">Int32</ref>] | lpstruct | lpstr | struct)                            
                    </ms-specific>
                </code>
            </dd>
            <break/>
            <dt r="II.15.3"><ref ref="CallConv">CallConv</ref></dt>
            <dd><code>[instance [explicit]] (default | unmanaged cdecl | unmanaged fastcall | unmanaged stdcall | unmanaged thiscall | vararg)</code></dd>
            <dd>Manner of method calling</dd>
            <dt r="II.15.4"><ref ref="Param">Param</ref></dt>
            <dd><code>{\[int\] | \[opt\] | \[out\]} <ref ref="Type">Type</ref> [marshal \([<ref ref="NativeType">NativeType</ref>]\)] [<ref ref="Id">Id</ref>]</code></dd>
            <dd>Method parameter definition</dd>
		</dl>
	</section>
    <!--General semantics-->
    <section id="general-semantic" guid="d603f693-9349-49ae-a10e-fb0b4aa5e200">
        <header>Semantics of general constructs</header>
        <introduction>
            This section describes semantics of some elements introduced in <ref ref="general-syntax">General syntactical constructs</ref>.
            Selected non-trivial elements are described in-dept and single parts of those elements are discussed.
        </introduction>
        <section id="Type" guid="cc8ddf5a-246d-45e7-a842-3b1a2a0c315b" r="II.7.1">
            <header><ref>Type</ref></header>
            <introduction>Complex reference to type.</introduction>
            <p>Can be one of following values:</p>
            <dl>
                <dt-code>!<ref ref="Int32">Int32</ref></dt-code>
                <dd>Reffres generic parameter from type declaration accessible by 0-based index.</dd>
                <dt-code>!!<ref ref="Int32">Int32</ref></dt-code>
                <dd>Reffres generic parameter from method declaration accessible by 0-based index.</dd>
                <break/>
                <dt-code>bool</dt-code>
                <dt-code>char</dt-code>
                <dt-code>float32</dt-code>
                <dt-code>float64</dt-code>
                <dt-code>int8</dt-code>
                <dt-code>int16</dt-code>
                <dt-code>int32</dt-code>
                <dt-code>int64</dt-code>
                <dt-code>object</dt-code>
                <dt-code>string</dt-code>
                <dt-code>unsigned int8</dt-code>
                <dt-code>unsigned int16</dt-code>
                <dt-code>unsigned int32</dt-code>
                <dt-code>unsigned int64</dt-code>
                <dt-code>native int</dt-code>
                <dt-code>native unsigned int</dt-code>
                <dd>Built-in types</dd>
                <break/>
                <dt-code>class <ref ref="TypeReference">TypeReference</ref></dt-code>
                <dd>Reference to user*defined type. See <ref ref="TypeReference">TypeReference</ref>.</dd>
                <break/>
                <dt-code>method <ref ref="CallConv">CallConv</ref> <ref ref="Type">Type</ref> \* \([<ref ref="Param">Param</ref> [, <ref ref="Param">Param</ref>]*]\)</dt-code>
                <dd>Method pointer. See <ref ref="CallConv">CallConv</ref>.</dd>
                <break/>
                <dt-code><ref ref="Type">Type</ref>&amp;</dt-code>
                <dd>Managed pointer to given type. Type cannot be managed pointer or <code>typedref</code>. Managed pointer is reported to garbage collector.</dd>
                <dt-code><ref ref="Type">Type</ref>*</dt-code>
                <dd>Unmanaged pointer to given type. Unmanaged pointer is not reported to garbage collector and behaves like unsigned integral number.</dd>
                <break/>
                <dt-code><ref ref="Type">Type</ref>&lt;<ref ref="Type">Type</ref> [, <ref ref="Type">Type</ref>]* [,]*></dt-code>
                <dd>
                    Generic type instance.
                    Generic parameter cannot be: Managed pointer (<code>ByRef</code>); type field of which points to CIL evaluation stack (like <see cref="T:System.RuntimeArgumentHandle"/>); <code>void</code>.
                    Partial instantiation is not allowed.
                </dd>
                <dt-code><ref ref="Type">Type</ref> \[[(... | <ref ref="Int32">Int32</ref> | <ref ref="Int32">Int32</ref> ... | <ref ref="Int32">Int32</ref> ... <ref ref="Int32">Int32</ref>) [, (... | <ref ref="Int32">Int32</ref> | <ref ref="Int32">Int32</ref> ... | <ref ref="Int32">Int32</ref> ... <ref ref="Int32">Int32</ref>)]*]\]</dt-code>
                <dd>Array. Several array declarations are possible.</dd>
                <dl>
                    <dt-code><ref ref="Type">type</ref> \[\]</dt-code>
                    <dd>
                        So-called vactor - one dimensional 0-based array
                        Vectors have special support in CIL - structrions <code-ref ref="newarr">newarr</code-ref>, <code-ref ref="ldelem">ldelem</code-ref>, <code-ref ref="stelem">stelem</code-ref> or <code-ref ref="stelema">stelema</code-ref>.
                        Vectors are subclasses of the <see cref="T:System.Array"/> class.
                    </dd>
                    <break/>
                    <dt-code><ref ref="Type">type</ref> \[<ref>Bound</ref> [, <ref>Bound</ref>]*\]</dt-code>
                    <dd>Array are defined by number of its dimensions. Each dimension is defined by boundaries <code-ref>Bound</code-ref> - it can be:</dd>
                    <dl>
                        <dt-code>...</dt-code>
                        <dd>Lower bound and upper bound undefined.</dd>
                        <dt-code><ref ref="Int32">Int32</ref></dt-code>
                        <dd>Lower bound 0 and uppper bound given number.</dd>
                        <dt-code><ref ref="Int32">Int32</ref> ...</dt-code>
                        <dd>Only lowe bound specified</dd>
                       <dt-code><ref ref="Int32">Int32</ref> ... <ref ref="Int32">Int32</ref></dt-code>
                        <dd>Both bounds specified</dd>
                    </dl>
                    <dd>Those arrays are supported by VES as subclasses of the <see cref="T:System.Array"/> class.</dd>
                    <dd>It as possible to created arrays of arrays, too.</dd>
                </dl>
                <break/>
                <dt-code><ref ref="Type">Type</ref> modopt \(<ref ref="TypeReference">TypeReference</ref>\)</dt-code>
                <dd>User modifier (optional modifier) which is not required to be understood by caller.</dd>
                <dt-code><ref ref="Type">Type</ref> modreq \(<ref ref="TypeReference">TypeReference</ref>\)</dt-code>
                <dd>User modifier (required modifier) which is required to be understood by caller.</dd>
                <dd rel="summary">
                    Modifiers are something like user-attributes, but are part of signature.
                    Each modifier associates reference to type with signature item.
                    CLI treats required and optional modifiers same way.
                    Two signatures that differ only by user modifiers are considered to be different.
                    User modifiers has no meaning for VES.
                    The fact that modifier is required or optional is meaningful to tools other than CLI (like alalyzers or compilers), which decides wheather modifier has any semantics they have to understand to.
                </dd>
                <break/>
                <dt-code><ref ref="Type">Type</ref> pinned</dt-code>
                <dd>Can be used only with local variables of methods.</dd>
                <dd>In case method in which variable of pinned type is declared is being executed, VES cannot move the object which variable is reference to.</dd>
                <dd>In case unmanaged pointers to managed objects are used, such object should be declared as pinned.</dd>
                <break/>
                <dt-code>typedref</dt-code>
                <dd>
                    Reference to type (i.e. <see cref="T:System.TypedReference"/>) created by <code-ref ref="mkrefany">mkrefany</code-ref>.
                    Used by instructions <code-ref ref="refanytype">refanytype</code-ref> and <code-ref ref="refanyval">refanyval</code-ref>.
                </dd>
                <break/>
                <dt-code>valuetype <ref ref="TypeReference">TypeReference</ref></dt-code>
                <dd>User-defined value-type (structure) - not boxed.</dd>
                <break/>
                <dt-code>void</dt-code>
                <dd>No type. Allowed only as return type of method or as part of definition opf unmanaged pointer <code>void*</code>.</dd>
            </dl>
        </section>
        <section id="TypeReference" guid="babaf4d8-f217-4265-a3ca-e64f2c1a5e77">
            <header><ref>TypeReference</ref></header>
            <introduction>Reference to user-defined type.</introduction>
			<syntax>[<ref>ResolutionScope</ref>] <ref ref="DottedName">DottedName</ref> [/ <ref ref="DottedName">DottedName</ref>]*</syntax>
			<dl>
				<dt><code-ref>ResolutionScope</code-ref> (<ref>ResolutionScope</ref>)</dt>
				<dd>If absent this reference is reference to same module of same assembly.</dd>
				<dl>
					<dt-code>\[.module <ref ref="FileName">FileName</ref>\]</dt-code>
					<dd>Reference to another module of same assembly.</dd>
					<dl>
						<dt><code-ref>FileName</code-ref> (<ref ref="DottedName">DottedName</ref>)</dt>
						<dd>Name of file containing the module. It must be module of same assembly.</dd>
					</dl>
					<dt-code>\[AssemblyRefName\]</dt-code>
					<dd>Reference to another assembly</dd>
					<dl>
						<dt><code-ref>AssemblyName</code-ref> (<ref ref="DottedName">DottedName</ref>)</dt>
						<dd>Name of referenced assembly defined using <code><internal-link ref="_assembly_externB">.assembly extern {}</internal-link></code>.</dd>
					</dl>
				</dl>
				<dt-code><ref ref="DottedName">DottedName</ref> / <ref ref="DottedName">DottedName</ref></dt-code>
				<dd>Type name. Slash is used to delimit name of containing type and nested type.</dd>
			</dl>
        </section>
		<section id="TypeSpec" guid="f86debe4-aec0-4361-9ac9-c21a93ff4e8c">
			<header><ref>TypeSpec</ref></header>
			<introduction>Simplified type reference</introduction>
			<p>
				<ref ref="TypeSpec">TypeSpec</ref> allows to use <ref ref="Type">Type</ref>, <ref ref="TypeReference">TypeReference</ref> and syntactical shortcut <code>\[[.module] <ref ref="DottedName">DottedName</ref>\]</code> in same place.
				So, it is possible e.g. instead of <code>class System.GC</code> use only <code>System.GC</code>.
			</p>
		</section>
		<section id="GenPar" guid="35f0f3eb-c612-4400-ba82-83532012bb0d">
			<header><ref>GenPar</ref></header>
			<introduction>Specifies a generic parameter.</introduction>
			<syntax>{[\+|-] | (class | valuetype) | .ctor} [\([<ref ref="Type">Type</ref> [, <ref ref="Type">Type</ref>]*\)] <ref ref="Id">Id</ref></syntax>
			<dl>
				<dt-code>+</dt-code>
				<dd>Covariant generic parameter</dd>
				<dd>
					Covariance means that when we have type <code>IA&lt;+T></code>, value of type <code>IA`&lt;A></code> can be assigned to target of type <code>IA`&lt;B></code> as long as it is possible to assgn value of type <code>A</code> to target of type <code>B</code>.
					For example following pseudo-code would be OK:			
				</dd>
                <example><code-ml><![CDATA[interface IA<+T>;
IA`1<System.String> var1;
IA`1<System.Object> var2;
var1 := var2;]]></code-ml></example>
                <dd>Covariant generic parameters can be used as method return types and can be used for creating covariant method return types.</dd>
                <example><code-ml><![CDATA[interface IEnumerator<+T> { T Current {get;} bool MoveNext(); }
interface IEnumerable<+T> { IEnumerator<T> GetEnumerator(); }]]></code-ml></example>
                <dt-code>-</dt-code>
                <dd>Contravariant generic parameter</dd>
                <dd>
                    Contravariance if compagnon to covariance. Having type <code>IB&lt;-T></code> we can do assignment <code>IB`1&lt;B> := IB`1&lt;A></code> as long as assignment <code>A := B</code> is possible.
                </dd>
                <example><code-ml><![CDATA[Interface IB<-T>;
IB`1<System.String> var1;
IB`1<System.Object> var2;
var2 := var1;]]></code-ml></example>
                <dd>Contravarian generic parameters can be used as method parameters types and can be used for constructing contravariant interfaces.</dd>
                <example><code-ml><![CDATA[interface IComparer<-T> { bool Compare(T x, T y); }
interface IKeyComparer<-T> : IComparer<T> { bool Compare(T x, T y); int GetHashCode(T obj); }]]></code-ml></example>
                <dd>Contravariant generic parameter can be used only in place of <i>producer</i>, <i>reader</i> or <i>getter</i>.</dd>
                <dd rel="summary"><b>Summary:</b></dd>
                <dd rel="summary">B → A ⇒ I&lt;+B> → I&lt;+A></dd>
                <dd rel="summary">B → A ⇒ I&lt;-A> → I&lt;-B></dd>
                <dd rel="summary">
                    <code>+</code> and <code>-</code> cannot be used simultaneously. In case none of them is used generic parameter is called non-variant.
                    There are no restrictions for using non-variant generic parameters.
                </dd>
                <dd rel="summary">Covariance and contravariance can be used only with delegates and interfaces.</dd>
                <break/>
                <dt-code>class</dt-code>
                <dd>Generic parameter must be of type class (reference) not structure (value).</dd>
                <dt-code>valuetype</dt-code>
                <dd>Generic parameter must be of value type (structure, not class - reference type), but cannot be <see cref="T:System.Nullable`1">System.Nullable&lt;T></see>.</dd>
                <dd rel="summary">Restrictions <code>class</code> and <code>valuetype</code> shall not be combined.</dd>
                <dt-code>.ctor</dt-code>
                <dd>Type parameter must be non-abstract class (reference type) with public constructor without parameters (default constructor) or it must be structure (value type).</dd>
                <dd rel="summary">Each of attributes <code>+</code>, <code>-</code>, <code>class</code>, <code>valuetype</code> and <code>.ctor</code> can be used maximally once.</dd>
                <break/>
                <dt><code-ref ref="Type">Type</code-ref> (<ref ref="Type">Type</ref>)</dt>
                <dd>Specifies restriction types for generic parameter. Type passed to generic parameter have to implement or inherit all listed types (so it makes sence to list maximally one class and several interfaces - no structures or delegates). Type passed to generic parameter might also be constraint type itself.</dd>
                <break/>
                <dt><code-ref ref="Id">Id</code-ref> (<ref ref="Id">Id</ref>)</dt>
                <dd>Name of generic parameter.</dd>
			</dl>
		</section>
        <section id="CallConv" guid="a190d1ff-f658-4705-91f4-cc0f171bd1f3">
            <header><ref>CallConv</ref></header>
            <introduction>Defines which way the method is called.</introduction>
            <syntax>[instance [explicit]] [default | unmanaged cdecl | unmanaged fastcalll | unmanaged stdcall | unmanaged thiscall | vararg]</syntax>
            <dl>
                <dt-code>instance</dt-code>
                <dd>This call is call of instance method (other possibility is static method). Pointer to current instance (so-called this-pointer) is passed to method.</dd>
                <dt-code>explicit</dt-code>
                <dd>
                    This class of instance method uses explicitly passed this-pointer.
                    Normally this-pointer is not part of argument list of method call, because it can be obtained from context.
                    In case of explicit call first item of parameter list is this pointer.
                </dd>
                <break />
                <dt-code>default</dt-code>
                <dd>Default way of calling managed methods. It shall be used always for managed method, unless <code>vararg</code> is required.</dd>
                <dt-code>unmanaged cdecl</dt-code>
                <dd>Call used by standard C language.</dd>
                <dt-code>unmanaged stdcall</dt-code>
                <dd>Call used by standard C++ language.</dd>
                <dt-code>unmanaged fastcall</dt-code>
                <dd>Special optimized way of calling used by C++.</dd>
                <dt-code>unmanaged thiscall</dt-code>
                <dd>C++ call with this-pointer.</dd>
                <break/>
                <dt-code>vararg</dt-code>
                <dd>Method accepts more arguments</dd>
            </dl>
        </section>
    </section>
</ildoc>
