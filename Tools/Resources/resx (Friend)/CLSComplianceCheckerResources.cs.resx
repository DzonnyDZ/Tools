<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="e_TypeInAssembly" xml:space="preserve">
    <value>Chyba při získávání typů v sestavení. Některý typy nebyly načteny.</value>
  </data>
  <data name="e_ModulesInAssembly" xml:space="preserve">
    <value>Chyba při získávání modulů v sestavení.</value>
  </data>
  <data name="e_AttributeUsageAttribute" xml:space="preserve">
    <value>Nemohu získat atribut AttributeUsageAttribute.</value>
  </data>
  <data name="AttributeUsage_AllowMultiple" xml:space="preserve">
    <value>Porušení AttributeUSage.AllowMultiple, atribute {0} je použit vícekrát.</value>
  </data>
  <data name="AttributeUsage_ValidOn" xml:space="preserve">
    <value>Porušení AttributeUsage.ValidOn, atribut {0} nemůže být aplikován na položku typu {1}.</value>
  </data>
  <data name="e_TypesInModule_some" xml:space="preserve">
    <value>Chyba při získávání typů v modulu. Některé typy nebyly načteny.</value>
  </data>
  <data name="e_TypesInModule" xml:space="preserve">
    <value>CHyba při získávání typů v modulu.</value>
  </data>
  <data name="e_MethodsInModule" xml:space="preserve">
    <value>Chyba při získávání metod v modulu.</value>
  </data>
  <data name="GlobalMethods" xml:space="preserve">
    <value>Globální metody nejsou CLS-kompatibilní.</value>
  </data>
  <data name="e_FieldsInModule" xml:space="preserve">
    <value>Chyba při získávání proměnných v modulu.</value>
  </data>
  <data name="GlobalFields" xml:space="preserve">
    <value>Globální proměnné nejsou CLS-kompatibilní.</value>
  </data>
  <data name="InheritCLSCompliant" xml:space="preserve">
    <value>CLS-kompatibilní typ může dědit jen od CLS-kompatibilního typu.</value>
  </data>
  <data name="NestedGenericTypeParametersCount" xml:space="preserve">
    <value>Typ vnořený do generického typu musí mít nejméně tolik typových parametrů jako typ, do něhož je vnořen.</value>
  </data>
  <data name="NameOfGenericType" xml:space="preserve">
    <value>Název generického typu musí obsahovat určení počtu generických parametrů.</value>
  </data>
  <data name="NameOfNestedGenericType" xml:space="preserve">
    <value>Název vnořeného typu musí obsahovat počet typových parametrů přidaných vnořeným typem oproti typu, ve kterém je vnořen.</value>
  </data>
  <data name="NestedGenericConstraint" xml:space="preserve">
    <value>Pokud typový parametr specifikuje omezení, odpovídající parametr vnořeného typu jej musí specifikovat také. Parametr {0} typu {1} postrádá ometení na typ {2}.</value>
  </data>
  <data name="NestedGenericConstraint_New" xml:space="preserve">
    <value>Pokud typový parametr specifikuje omezení výchozí konstruktor, odpovídající parametr vnořeného typu jej musí specifikovat také.</value>
  </data>
  <data name="NestedGenericConstraint_Struct" xml:space="preserve">
    <value>Pokud typový parametr specifikuje omezení hodnotový typ (nenullovatelný), odpovídající parametr vnořeného typu jej musí specifikovat také.</value>
  </data>
  <data name="NestedGenericConstraint_Class" xml:space="preserve">
    <value>Pokud typový parametr specifikuje omezení referenční typ, odpovídající parametr vnořeného typu jej musí specifikovat také.</value>
  </data>
  <data name="e_MembersInType" xml:space="preserve">
    <value>Chyba při získávání členů typu.</value>
  </data>
  <data name="UniqueSignature" xml:space="preserve">
    <value>Signatura člena není unikátní.</value>
  </data>
  <data name="EnumerationOnlyFields" xml:space="preserve">
    <value>Výčet smí obsahovat je proměnné.</value>
  </data>
  <data name="EnumerationFieldKind" xml:space="preserve">
    <value>Proměnné ve výčtu musí být buďto statické literály nebo instanční proměnná s názvem "value__" označená RTSpecialName.</value>
  </data>
  <data name="EnumerationValue__Type" xml:space="preserve">
    <value>Typ proměnné výčtu value__ musí být typu, na němž je výčet postaven.</value>
  </data>
  <data name="EnumerationLiteralStatic" xml:space="preserve">
    <value>Členské literály výčtu musí být statické.</value>
  </data>
  <data name="TypeOfEnumMember" xml:space="preserve">
    <value>Členské literály výčtu musí být stejného typu jako výčet.</value>
  </data>
  <data name="InterfaceCLSIncompliantMember" xml:space="preserve">
    <value>Rozhraní nesmí vyžadovat implementaci CLS-nekompatibilních členů ke své implementaci.</value>
  </data>
  <data name="InterfaceStaticMethod" xml:space="preserve">
    <value>Rozhraní nesmí deklarovat statické metody.</value>
  </data>
  <data name="InterfaceField" xml:space="preserve">
    <value>Rozhraní nesmí deklarovat proměnné.</value>
  </data>
  <data name="RequireImplementIncompliant" xml:space="preserve">
    <value>CLS-kompatibilní typ nesmí vyžadovat implementaci CLS-nekompatibilních členů.</value>
  </data>
  <data name="MissingValue__" xml:space="preserve">
    <value>Výčet postrádá proměnnou value__.</value>
  </data>
  <data name="EnumType" xml:space="preserve">
    <value>Výčet není postaven na vestavěném CLS-kompatibilním celočíselném typu.</value>
  </data>
  <data name="CLSCompliantInCLSIncompliant" xml:space="preserve">
    <value>Člem CLS-nekompatibilního typu označen jako CLS-kompatibilní.</value>
  </data>
  <data name="PropertyType" xml:space="preserve">
    <value>Typ vlastnosti není CLS-kompatibilní.</value>
  </data>
  <data name="e_IndexesInProperty" xml:space="preserve">
    <value>Nemohu zístak indexové paramery vlastnosti.</value>
  </data>
  <data name="NoPropertyAccesor" xml:space="preserve">
    <value>Vlastnost nemá žádné metody.</value>
  </data>
  <data name="SetterSpecialName" xml:space="preserve">
    <value>Setter vlastnosti musí být označen specialname.</value>
  </data>
  <data name="GetterSetterStatic" xml:space="preserve">
    <value>Setter i getter vlastnosti musí být oba buď statické nebo instanční.</value>
  </data>
  <data name="GetterSetterVirtual" xml:space="preserve">
    <value>Setter i getter vlastnosti musí být oba buď virtuální nebo nevirtuální.</value>
  </data>
  <data name="GetterSpecialName" xml:space="preserve">
    <value>Getter vlastnosti musí být označen spacialname.</value>
  </data>
  <data name="ParametersInGetter" xml:space="preserve">
    <value>Nemohu získat parametry getteru vlastnosti.</value>
  </data>
  <data name="GetterType" xml:space="preserve">
    <value>Návratový typ getteru vlastnosti musí být stejný jako typ vlastnosti.</value>
  </data>
  <data name="GetterParametersCount" xml:space="preserve">
    <value>Počet parametrů vlastnosti a getteru musí být stejný.</value>
  </data>
  <data name="GetterName" xml:space="preserve">
    <value>Název getteru vlastnosti musí být get_&lt;název vlastnosti&gt; (očekáváno "{0}", skutečně "{1}").</value>
  </data>
  <data name="e_ParametersInSetter" xml:space="preserve">
    <value>Nemohu získat paremetry getteru vlastnosti.</value>
  </data>
  <data name="SetterLastParam" xml:space="preserve">
    <value>Typ posledního parametru setteru vlastnosti musí být stejný jako typ vlastnosti.</value>
  </data>
  <data name="SetterParametersCount" xml:space="preserve">
    <value>Setter vlastnosti musí mít přesně o jeden parametry více než vlastnost.</value>
  </data>
  <data name="SetterName" xml:space="preserve">
    <value>Název setteru vlastnosti musí být set_&lt;název vlastnosti&gt; (očekáváno "{0}", skutečně "{1}").</value>
  </data>
  <data name="IndexType" xml:space="preserve">
    <value>Indexový parametry proměnné {0} není CLS-kompatibilní.</value>
  </data>
  <data name="PropertyByRef" xml:space="preserve">
    <value>Parametry vlasnosti nesmí být předáván referencí.</value>
  </data>
  <data name="PropertySetterParameters" xml:space="preserve">
    <value>Parametry setteru vlastnosti musí být stejných typů jako parametry vlastnosti (až na poslední parametr setteru).</value>
  </data>
  <data name="PropertyGetterParameters" xml:space="preserve">
    <value>Parametry getteru vlastnosti musí být stejné jako parametry vlastnosti.</value>
  </data>
  <data name="Modreqs" xml:space="preserve">
    <value>CLS nepovoluje povinné uživatelské modifikátory (modreq).</value>
  </data>
  <data name="EventType" xml:space="preserve">
    <value>Type delegáta události není CLS-kompatibilní.</value>
  </data>
  <data name="AddRemoveBothOrNo" xml:space="preserve">
    <value>Metody události add a remove musí být buď obě přítomny nebo obě nepřítomny.</value>
  </data>
  <data name="EventTypeDelegate" xml:space="preserve">
    <value>Type události musí být delegát.</value>
  </data>
  <data name="AddSpecialName" xml:space="preserve">
    <value>Metoda události add musí být označena jako specialname.</value>
  </data>
  <data name="AddParameters" xml:space="preserve">
    <value>Metoda události add musí přijímat právě jeden parametry typu delegáta události.</value>
  </data>
  <data name="AddName" xml:space="preserve">
    <value>Název metody události add musí být pojmenována add_&lt;název události&gt;.</value>
  </data>
  <data name="RemoveSpecialName" xml:space="preserve">
    <value>Metoda události remove musí být označena jako specialname.</value>
  </data>
  <data name="EventAccessorsVisibility" xml:space="preserve">
    <value>Metody události musí mít stejnou úroveň přístupu.</value>
  </data>
  <data name="RemoveParameters" xml:space="preserve">
    <value>Metoda události remova musí přijímat právě jeden parametr typu delegáta události.</value>
  </data>
  <data name="RemoveName" xml:space="preserve">
    <value>Metoda události remove musí být pojmenována remove_&lt;neázev události&gt;.</value>
  </data>
  <data name="RaiseSpecialName" xml:space="preserve">
    <value>Metoda události raise musí být označena jako specialname.</value>
  </data>
  <data name="RaiseName" xml:space="preserve">
    <value>Metoda události raise musí být pojmenována raise_&lt;název události&gt;.</value>
  </data>
  <data name="OverrididedLevel" xml:space="preserve">
    <value>Přepisující metoda musí mýt stejnou úroveň přístupnosti jako metoda, kterou přepisuje. Jen dostupnost sestavení nebo rodina může být změněna na dostupnost rodina, pokud je přepisující metoda v jiném sestavení, než metoda, kterou přepisuje.</value>
  </data>
  <data name="e_ParamsInMethod" xml:space="preserve">
    <value>Chyba při získávání parametrů metody.</value>
  </data>
  <data name="ParamType" xml:space="preserve">
    <value>Parametr {0} není CLS-kompatibilního typu.</value>
  </data>
  <data name="ReturnType" xml:space="preserve">
    <value>Návratový typ metody není CLS-kompatibilní.</value>
  </data>
  <data name="StandardCallingConvention" xml:space="preserve">
    <value>Jediná podporovaná volací konvence je standardní.</value>
  </data>
  <data name="GenericParamType" xml:space="preserve">
    <value>Typ {0} předaný do generického typu není CLS-kompatibilní.</value>
  </data>
  <data name="IncompliantType" xml:space="preserve">
    <value>Typ {0} není CLS-kompatibilní.</value>
  </data>
  <data name="TypedReference" xml:space="preserve">
    <value>TypedReference není CLS-kompatibilní.</value>
  </data>
  <data name="Array0" xml:space="preserve">
    <value>Pole musí mít spodní mez 0 ve vešech rozměrech.</value>
  </data>
  <data name="Pointer" xml:space="preserve">
    <value>Nespravované ukazatele nejsou CLS-kompatibilní.</value>
  </data>
  <data name="FieldType" xml:space="preserve">
    <value>Typ proměnné není CLS-kompatibilní.</value>
  </data>
  <data name="ConstantValue" xml:space="preserve">
    <value>Konstantní hodnota specifikovaná v metadatech není stejného typu jako je typ proměnné.</value>
  </data>
  <data name="e_CustomAttributes" xml:space="preserve">
    <value>Nemohu získat uživatelské atributy.</value>
  </data>
  <data name="NoAttributeAttribute" xml:space="preserve">
    <value>Typ atributu {0} nedědí od System.Attribute.</value>
  </data>
  <data name="CLSInclompliantAttribute" xml:space="preserve">
    <value>Použití CLS-nekompatibilního atributu {0}.</value>
  </data>
  <data name="CustomAttributeDataInaccessible" xml:space="preserve">
    <value>Nemohu ověřit data uživatelských atributů pro {0}, protože {0} neposkytuje přístup k datům uživatelských atributů.</value>
  </data>
  <data name="AttributeParamType" xml:space="preserve">
    <value>Hodnota konstruktoru uživatelského atributu {0} je kódována za použití CLS-nekompatibilního typu {1}.</value>
  </data>
  <data name="AttributeNamedParamType" xml:space="preserve">
    <value>Hodnota pojmenovaného parametru {0} uživatelského atributu {1} je kódována za použití CLS-nekompatibilního typu {2}.</value>
  </data>
  <data name="Name" xml:space="preserve">
    <value>Název "{0}" není CLS-kompatibilní.</value>
  </data>
  <data name="NameC" xml:space="preserve">
    <value>Název "{0}" není uložen v Unicode normalizační formě C.</value>
  </data>
  <data name="UniqueName" xml:space="preserve">
    <value>Kulturně invariantní reprezentace názvu typu "{0}" malými písmeny není unikátní.</value>
  </data>
  <data name="ExposeFriend" xml:space="preserve">
    <value>{0} vystavuje typ {1}, který není dostupný zvenčí sestavení.</value>
  </data>
  <data name="ExposeNested" xml:space="preserve">
    <value>{0} vystavuje typ {1}, který není dostupný z venčí typu {2}.</value>
  </data>
  <data name="e_GenericParametersInType" xml:space="preserve">
    <value>Nemohu získat generické parametry typu {0}.</value>
  </data>
  <data name="VarArgsAreNotCLSCompliant" xml:space="preserve">
    <value>VarArgs nejsou CLS-kompatibilní.</value>
  </data>
</root>