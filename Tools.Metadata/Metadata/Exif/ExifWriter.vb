Imports Tools.MetadataT.ExifT.ExifReader, Tools.ExtensionsT.StringExtensions

#If Config <= Nightly Then 'Stage:Nightly
Namespace MetadataT.ExifT
    ''' <summary>This class provides low-level writer of Exif matadata</summary>
    ''' <version stage="Nightly" version="1.5.2">Class accessibility changed from Firend to Public</version>
    ''' <version version="1.5.2">New overloaded method <see cref="ExifWriter.Save"/> introduced.</version>
    Public Class ExifWriter
#Region "Common"
        ''' <summary>Contains value of the <see cref="Writer"/> property</summary>
        Private _Writer As IOt.BinaryWriter
        ''' <summary>Contains stream to write data to</summary>
        Protected ReadOnly Property Writer() As IO.BinaryWriter
            Get
                Return _Writer
            End Get
        End Property
        ''' <summary>Reader over stream data are written to</summary>
        Private Reader As IOt.BinaryReader
        ''' <summary>May contain map of stream if map is associated</summary>
        Private Map As ReaderItemKinds()
        ''' <summary>Contains new map generated by writer</summary>
        Private NewMap As New List(Of ReaderItemKinds)
        ''' <summary>Gets copy of output map created while writing Exif metadata to the stream</summary>
        ''' <returns>Output map describing usage of bytes in output stream</returns>
        ''' <remarks>Reaturned array does contain neither items with set <see cref="ReaderItemKinds.WriterMask"/> nor <see cref="ReaderItemKinds.Empty"/></remarks>
        Public ReadOnly Property OutputMap() As ReaderItemKinds()
            Get
                Dim ret = NewMap.ToArray
                For i As Integer = 0 To ret.Length - 1
                    ret(i) = ret(i) And Not ReaderItemKinds.WriterMask
                    If ret(i) = ReaderItemKinds.Empty Then ret(i) = ReaderItemKinds.Unknown
                Next
                Return ret
            End Get
        End Property
        ''' <summary>States of writer</summary>
        Public Enum WriterStates
            ''' <summary>Before start of writing</summary>
            Beginning = 0
            ''' <summary>General state, IFDs can be written</summary>
            General
            ''' <summary>Writer is writing records inside IFD</summary>
            Records
            ''' <summary>writing was finished</summary>
            ''' <seealso cref="EndWriting"/>
            Finnished
        End Enum
        ''' <summary>Contains value of the <see cref="WriterState"/> property</summary>
        Private _WriterState As WriterStates = WriterStates.Beginning
        ''' <summary>Gets or sets current state of writer</summary>
        ''' <exception cref="InvalidEnumArgumentException">Value being set is not member of <paramref name="writerstates"/></exception>
        Public Property WriterState() As WriterStates
            Get
                Return _WriterState
            End Get
            Protected Set(ByVal value As WriterStates)
                If Not InEnum(value) Then Throw New InvalidEnumArgumentException("value", value, value.GetType)
                _WriterState = value
            End Set
        End Property
#End Region
#Region "CTors"
        ''' <summary>CTor - creates new instance of <see cref="ExifWriter"/> for new Exif metadata stream</summary>
        ''' <param name="Stream">Stream to write data to</param>
        ''' <param name="ByteAlign">Exif byte align</param>
        ''' <remarks>This constructor creates instance of writer that cannot preserve unknown metadata from originals stream (like maker notes)</remarks>
        ''' <exception cref="ArgumentNullException"><paramref name="Stream"/> is null</exception>
        ''' <exception cref="ArgumentException"><paramref name="Stream"/> does not support reading, seeking and writing</exception>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="Align"/> is not member of <see cref="iot.BinaryReader.ByteAlign"/></exception>
        Public Sub New(ByVal Stream As IO.Stream, Optional ByVal ByteAlign As IOt.BinaryReader.ByteAlign = IOt.BinaryReader.ByteAlign.LittleEndian)
            If Stream Is Nothing Then Throw New ArgumentNullException("Stream")
            If Not Stream.CanRead OrElse Not Stream.CanSeek OrElse Not Stream.CanWrite Then Throw New ArgumentException(ResourcesT.Exceptions.StreamToWriteExifMedatadaToMustSupportReadingWritingAndSeeking)
            _Writer = New IOt.BinaryWriter(Stream, System.Text.Encoding.ASCII, ByteAlign)
            Me.Reader = New IOt.BinaryReader(Stream, System.Text.Encoding.ASCII, ByteAlign)
        End Sub
        ''' <summary>CTor - creates new instance of <see cref="ExifWriter"/> for exisitin Exif metadata stream</summary>
        ''' <param name="Stream">Stream that contains original Exif metadata</param>
        ''' <param name="Map">Map of <paramref name="Stream"/> (usually generated by <see cref="ExifMapGenerator"/>).</param>
        ''' <exception cref="ArgumentNullException"><paramref name="Stream"/> or <paramref name="Map"/> is null</exception>
        ''' <exception cref="ArgumentException"><paramref name="Stream"/> cannot read, write or seek -or- lengths of <paramref name="Map"/> nas <paramref name="Stream"/> differs -or- Lenght of <paramref name="Stream"/> is less than 12 -or- <paramref name="Stream"/> contains invalid byte order marker -or- Byte order marker present at <paramref name="Stream"/> is violated by following byte order marker test -or- <paramref name="Map"/> does not start with 2×<see cref="readeritemkinds.Bom"/>, 2×<see cref="ReaderItemKinds.BomTest"/> and 4× <see cref="ReaderItemKinds.Ifd0Offset"/> -or- <paramref name="Map"/> contains writer-generated item (which or-masks with <see cref="ReaderItemKinds.writermask"/>).</exception>
        ''' <version version="1.5.2">Fixed: <see cref="ArgumentException"/> ("Begining of Exif map is invalid") is always thrown.</version>
        Public Sub New(ByVal Stream As IO.Stream, ByVal Map As ReaderItemKinds())
            If Stream Is Nothing Then Throw New ArgumentNullException("Stream")
            If Map Is Nothing Then Throw New ArgumentNullException("Map")
            If Not Stream.CanRead OrElse Not Stream.CanSeek OrElse Not Stream.CanWrite Then Throw New ArgumentException(ResourcesT.Exceptions.StreamToWriteExifMedatadaToMustSupportReadingWritingAndSeeking)
            If Map.Length <> Stream.Length Then Throw New ArgumentException(ResourcesT.Exceptions.ExifStreamAndMapMustHaveSameLengths)
            If Stream.Length < 12 Then Throw New ArgumentException(ResourcesT.Exceptions.OriginalExifStreamMustBeAlLeast12BytesLong)
            Stream.Position = 0
            Dim reader As New IO.BinaryReader(Stream, System.Text.Encoding.ASCII)
            Dim bom = reader.ReadChars(2)
            Dim ba As IOt.BinaryReader.ByteAlign
            If bom = "MM" Then
                ba = IOt.BinaryReader.ByteAlign.BigEndian
            ElseIf bom = "II" Then
                ba = IOt.BinaryReader.ByteAlign.LittleEndian
            Else
                Throw New ArgumentException(ResourcesT.Exceptions.SuppliedStreamHasInvalidByteOrderMarker)
            End If
            Me._Writer = New IOt.BinaryWriter(Stream, System.Text.Encoding.ASCII, ba)
            Me.Reader = New IOt.BinaryReader(Stream, System.Text.Encoding.ASCII, ba)
            If Me.Reader.ReadUInt16 <> &H2AUS Then Throw New ArgumentException(ResourcesT.Exceptions.SuppliedStreamByteOrderDoesNotMatchByteOrderTestWord)
            If Map(0) <> ReaderItemKinds.Bom OrElse Map(1) <> ReaderItemKinds.Bom OrElse Map(2) <> ReaderItemKinds.BomTest OrElse Map(3) <> ReaderItemKinds.BomTest OrElse Map(4) <> ReaderItemKinds.Ifd0Offset OrElse Map(5) <> ReaderItemKinds.Ifd0Offset OrElse Map(6) <> ReaderItemKinds.Ifd0Offset OrElse Map(7) <> ReaderItemKinds.Ifd0Offset Then _
                Throw New ArgumentException(ResourcesT.Exceptions.TheBeginnignOfExifMapIsInvalid)
            For Each item In Map
                If (item And ReaderItemKinds.WriterMask) = ReaderItemKinds.WriterMask Then Throw New ArgumentException(ResourcesT.Exceptions.ExifMapIsInvalidBecauseItContainsWriterGeneratedItems, "Map")
            Next
            Me.Map = Map.Clone
        End Sub
#End Region
#Region "Public properties"
        ''' <summary>Contains value of the <see cref="PreserveThumbnail"/> property</summary>
        Private _PreserveThumbnail As Boolean = False
        ''' <summary>Gets or sets value indicating if thumbnail will be preserved in original stream</summary>
        ''' <returns>Value indicating if thumbnail will be preserved in original stream</returns>
        ''' <value>Default value is false. Chage it to true if you want ot preserve Exif thumbnail in original stream (if there is any) and you are not giong to write own thumbnail in there.</value>
        ''' <exception cref="InvalidOperationException">Writing has already started -or- This instance was not given map of original steream in CTor.</exception>
        Public Property PreserveThumbnail() As Boolean
            Get
                Return _PreserveThumbnail
            End Get
            Set(ByVal value As Boolean)
                If value <> PreserveThumbnail AndAlso WriterState <> WriterStates.Beginning Then Throw New InvalidOperationException(ResourcesT.Exceptions.PreserveThumbnailCannotBeChangedAfterWritingOfDataStarted)
                If value <> False AndAlso Map Is Nothing Then Throw New InvalidOperationException(ResourcesT.Exceptions.ThumbnailCanBePreservedOnlyIfExifWriterOperatesOverAlreadyExistingStreamOfExifMetadata)
                _PreserveThumbnail = value
            End Set
        End Property
#End Region
#Region "Write"
        ''' <summary>Writes Exif TIFF header</summary>
        ''' <returns>4 - offset where pointer to IFD0 must be written.</returns>
        ''' <remarks>This must be first call to writer. This call can appear only once.</remarks>
        Public Function WriteHeader() As Integer
            If WriterState <> WriterStates.Beginning Then Throw New InvalidOperationException(ResourcesT.Exceptions.UnexpectedCallOf0.f("WriteHeader"))
            Writer.BaseStream.Position = 0
            If Map Is Nothing Then
                If _Writer.ByteOrder = IOt.BinaryReader.ByteAlign.BigEndian Then
                    Writer.Write("MM".ToCharArray)
                Else
                    Writer.Write("II".ToCharArray)
                End If
                Writer.Write(&H2AUS)
                NewMap.AddRange(New ReaderItemKinds() {ReaderItemKinds.Bom Or ReaderItemKinds.WriterMask, ReaderItemKinds.Bom Or ReaderItemKinds.WriterMask, ReaderItemKinds.BomTest Or ReaderItemKinds.WriterMask, ReaderItemKinds.BomTest Or ReaderItemKinds.WriterMask, _
                    ReaderItemKinds.Ifd0Offset Or ReaderItemKinds.WriterMask, ReaderItemKinds.Ifd0Offset Or ReaderItemKinds.WriterMask, ReaderItemKinds.Ifd0Offset Or ReaderItemKinds.WriterMask, ReaderItemKinds.Ifd0Offset Or ReaderItemKinds.WriterMask})
            Else
                Writer.Seek(4, IO.SeekOrigin.Current)
                For i As Integer = 0 To 7
                    Map(i) = Map(i) Or ReaderItemKinds.WriterMask
                    NewMap.Add(Map(i))
                Next i
            End If
            Writer.Write(0UI)
            WriterState = WriterStates.General
            LastPosition = Writer.BaseStream.Position
            Return 4
        End Function
        ''' <summary>In stream allocates space for IFD of given size</summary>
        ''' <param name="OffsetToPointer">Offset to pointer to IFD. Allocated position will be recorder here.</param>
        ''' <param name="NumberOfRecords">Number of records in IFD.</param>
        ''' <returns>Offset position of pointer to next IFD</returns>
        ''' <remarks>This method allocates space of size appropriate to IFD with given number of elements. There is almost no check (see exceptions) of validity of <paramref name="OffsetToPointer"/>. You must use value returned by <see cref="WriteHeader"/> or <see cref="AllocateIfd"/>, or use position of tag in order to write subIFD. This function also writes number of entries to allocated space and initializes pointer to next IFD to 0.</remarks>
        ''' <param name="PointerSize">Defines data type of pointer at <paramref name="OffsetToPointer"/>. Default type for IFDs is <see cref="PointerSizes.UInt32"/>.</param>
        ''' <exception cref="ArgumentOutOfRangeException"><paramref name="OffsetToPointer"/> is less than 4 -or- <paramref name="NumberOfRecords"/> is less then zer -or- <paramref name="NumberOfRecords"/> is greater than <see cref="UShort.MaxValue"/></exception>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="PointerSize"/> is not member of <see cref="PointerSizes"/></exception>
        ''' <exception cref="InvalidOperationException">IFD cannot be written in current state of writer. Such as previous IFD was not finnished yet or header was not written yet.</exception>
        ''' <exception cref="OverflowException">Offset found for IFD cannot be represented in datatype <paramref name="PointerSize"/></exception>
        ''' <param name="IsSubIfd">Indicates if IFD being written is SubIFD. This has only impact on output map.</param>
        Public Function AllocateIfd(ByVal OffsetToPointer As Integer, ByVal NumberOfRecords As Integer, Optional ByVal IsSubIfd As Boolean = False, Optional ByVal PointerSize As PointerSizes = PointerSizes.UInt32) As Integer
            If OffsetToPointer < 4 Then Throw New ArgumentOutOfRangeException("OffsetToPointer", ResourcesT.Exceptions.MustBeGreaterThanOrEqualTo1.f("OffsetToPointer", 4))
            If NumberOfRecords < 0 Then Throw New ArgumentOutOfRangeException("NumberOfRecords", ResourcesT.Exceptions.MustBeGreaterThanOrEqualToZero.f("NumberOfRecords"))
            If NumberOfRecords > UShort.MaxValue Then Throw New ArgumentOutOfRangeException("NumberOfRecords", ResourcesT.Exceptions.MustBeLessThenOrEqualTo1.f("NumberOfRecords", UShort.MaxValue))
            If Not InEnum(PointerSize) Then Throw New InvalidEnumArgumentException("PointerSize", PointerSize, PointerSize.GetType)
            If WriterState <> WriterStates.General Then Throw New InvalidOperationException(ResourcesT.Exceptions.CannotWriteIFDAtThisTime)
            Dim Position = FindFreeSpace(12 * NumberOfRecords + 2 + 4)
            Writer.Seek(OffsetToPointer, IO.SeekOrigin.Begin)
            Select Case PointerSize
                Case PointerSizes.Byte : Writer.Write(CByte(Position))
                Case PointerSizes.UInt16 : Writer.Write(CUShort(Position))
                Case PointerSizes.UInt32 : Writer.Write(CUInt(Position))
            End Select
            Writer.Seek(Position, IO.SeekOrigin.Begin)
            Writer.Write(CUShort(NumberOfRecords))
            Dim IfdOr = If(IsSubIfd, ReaderItemKinds.SubIfdMask, ReaderItemKinds.Unknown)
            WriterMap(Position) = ReaderItemKinds.IfdNumberOfEntries Or IfdOr
            WriterMap(Position + 1) = ReaderItemKinds.IfdNumberOfEntries Or IfdOr
            For i As Integer = 0 To NumberOfRecords - 1
                WriterMap(Position + 2 + i * 12 + 0) = ReaderItemKinds.TagNumber
                WriterMap(Position + 2 + i * 12 + 1) = ReaderItemKinds.TagNumber
                WriterMap(Position + 2 + i * 12 + 2) = ReaderItemKinds.TagDataType
                WriterMap(Position + 2 + i * 12 + 3) = ReaderItemKinds.TagDataType
                WriterMap(Position + 2 + i * 12 + 4) = ReaderItemKinds.TagComponents
                WriterMap(Position + 2 + i * 12 + 5) = ReaderItemKinds.TagComponents
                WriterMap(Position + 2 + i * 12 + 6) = ReaderItemKinds.TagComponents
                WriterMap(Position + 2 + i * 12 + 7) = ReaderItemKinds.TagComponents
                WriterMap(Position + 2 + i * 12 + 8) = ReaderItemKinds.TagDataOrOffset
                WriterMap(Position + 2 + i * 12 + 9) = ReaderItemKinds.TagDataOrOffset
                WriterMap(Position + 2 + i * 12 + 10) = ReaderItemKinds.TagDataOrOffset
                WriterMap(Position + 2 + i * 12 + 11) = ReaderItemKinds.TagDataOrOffset
            Next
            WriterMap(Position + 2 + 12 * NumberOfRecords + 0) = ReaderItemKinds.NextIfdOffset Or IfdOr
            WriterMap(Position + 2 + 12 * NumberOfRecords + 1) = ReaderItemKinds.NextIfdOffset Or IfdOr
            WriterMap(Position + 2 + 12 * NumberOfRecords + 2) = ReaderItemKinds.NextIfdOffset Or IfdOr
            WriterMap(Position + 2 + 12 * NumberOfRecords + 3) = ReaderItemKinds.NextIfdOffset Or IfdOr
            Writer.Seek(Position + 2 + 12 * NumberOfRecords, IO.SeekOrigin.Begin)
            Writer.Write(0UI)
            WriterState = WriterStates.Records
            _RecordsToWrite = NumberOfRecords
            _RecordsWritten = 0
            _FirstRecordOffset = Position + 2
            If Map Is Nothing Then LastPosition = Position + 2 + 12 * NumberOfRecords + 4
            Return Position + 2 + 12 * NumberOfRecords
        End Function
        ''' <summary>Writes directory entry record to output stream</summary>
        ''' <param name="Record">Record to be written</param>
        ''' <returns>Position where data was written</returns>
        ''' <exception cref="ArgumentNullException"><paramref name="Record"/> is null or <paramref name="Record"/>.<see cref="DirectoryEntry.Data">Data</see> is null</exception>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is not <see cref="WriterStates.Records"/> or all records have been already written</exception>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="Record"/>.<see cref="DirectoryEntry.DataType">DataType</see> is not member of <see cref="ExifDataTypes"/>.</exception>
        ''' <exception cref="TypeMismatchException"><paramref name="Record"/>.<see cref="DirectoryEntry.Data">Data</see> is of different type then is reported by <paramref name="Record"/>.<see cref="DirectoryEntry.DataType">DataType</see></exception>
        ''' <exception cref="ArgumentException"><paramref name="Record"/>.<see cref="DirectoryEntry.Components">Components</see> differes from number of components in <paramref name="Record"/>.<see cref="DirectoryEntry.Data">Data</see></exception>
        Public Function WriteRecord(ByVal Record As DirectoryEntry) As Integer
            If Record Is Nothing Then Throw New ArgumentNullException("Record")
            Return WriteRecord(Record.Tag, Record.DataType, Record.Components, Record.Data)
        End Function
        ''' <summary>Writes directory entry record to output stream</summary>
        ''' <param name="Record">Record to be written</param>
        ''' <param name="TagNumber">Number of record</param>
        ''' <returns>Position where data was written</returns>
        ''' <exception cref="ArgumentNullException"><paramref name="Record"/> is null or <paramref name="Record"/>.<see cref="ExifRecord.Data">Data</see> is null</exception>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is not <see cref="WriterStates.Records"/> or all records have been already written</exception>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="Record"/>.<see cref="ExifRecord.DataType">DataType</see>.<see cref="ExifRecordDescription.DataType">DataType</see> is not member of <see cref="ExifDataTypes"/>.</exception>
        ''' <exception cref="TypeMismatchException"><paramref name="Record"/>.<see cref="ExifRecord.Data">Data</see> is of different type then is reported by <paramref name="Record"/>.<see cref="ExifRecord.DataType">DataType</see>.<see cref="ExifRecordDescription.DataType">DataType</see></exception>
        ''' <exception cref="ArgumentException"><paramref name="Record"/>.<see cref="ExifRecord.DataType">¨DataType</see>.<see cref="ExifRecordDescription.NumberOfElements">NumberOfElements</see> differes from number of components in <paramref name="Record"/>.<see cref="ExifRecord.Data">Data</see></exception>
        ''' <exception cref="ArgumentOutOfRangeException"><paramref name="TagNumber"/> is less than zero or greater than <see cref="UShort.MaxValue"/></exception>
        Public Function WriteRecord(ByVal TagNumber As Integer, ByVal Record As ExifRecord) As Integer
            If Record Is Nothing Then Throw New ArgumentNullException("Record")
            If TagNumber < 0 OrElse TagNumber > UShort.MaxValue Then Throw New ArgumentOutOfRangeException("TagNumber", ResourcesT.Exceptions.MustBeWithinRange01.f("TagNumber", 0, UShort.MaxValue))
            Return WriteRecord(TagNumber, Record.DataType.DataType, Record.DataType.NumberOfElements, Record.Data)
        End Function
        ''' <summary>Writes record (directory entry) to output stream</summary>
        ''' <param name="TagNumber">Number of directory entry (so called tag number)</param>
        ''' <param name="DataType">Data type of directory entry</param>
        ''' <param name="NumberOfComponets">Number of components of type <paramref name="DataType"/> in this directory entry</param>
        ''' <param name="Data">Data to be written</param>
        ''' <returns>Position where data was written</returns>
        ''' <exception cref="ArgumentNullException"><paramref name="Data"/> is null</exception>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is not <see cref="WriterStates.Records"/> or all records have been already written</exception>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="DataType"/> is not member of <see cref="ExifDataTypes"/></exception>
        ''' <exception cref="TypeMismatchException"><paramref name="Data"/> is of different type then reported by <paramref name="DataType"/>. Acceptable types are scalars and 1D array of type reported by <paramref name="DataType"/>.</exception>
        ''' <exception cref="ArgumentException"><paramref name="NumberOfComponets"/> differs from number of items in <paramref name="Data"/></exception>
        ''' <remarks>This method is not CLS-compliant, but CLS-compliant overload with <see cref="DirectoryEntry"/> as parameter is available.</remarks>
        <CLSCompliant(False)> _
        Public Function WriteRecord(ByVal TagNumber As UShort, ByVal DataType As ExifDataTypes, ByVal NumberOfComponets As UInteger, ByVal Data As Object) As Integer
            If Data Is Nothing Then Throw New ArgumentNullException("Date")
            If WriterState <> WriterStates.Records Then Throw New InvalidOperationException(ResourcesT.Exceptions.RecordsCanBeWrittenOnlyWhenWriterStateIsRecords)
            If RecordsWritten >= RecordsToWrite Then Throw New InvalidOperationException(ResourcesT.Exceptions.AllRecordsHaveBennAlreadyWritten)
            If Not InEnum(DataType) Then Throw New InvalidEnumArgumentException("DataType", DataType, DataType.GetType)
            Dim Position = FirstRecordOffset + RecordsWritten * 12
            Writer.Seek(Position, IO.SeekOrigin.Begin)
            Writer.Write(TagNumber)
            Writer.Write(DataType)
            Writer.Write(NumberOfComponets)
            Dim DataNormalized = NormalizeData(Data, DataType)
            If DataNormalized Is Nothing Then Throw New TypeMismatchException("Data", Data, Nothing, ResourcesT.Exceptions.Type0IsNotAcceptableForDataType1.f(Data.GetType.Name, DataType))
            If DataNormalized.Length <> NumberOfComponets Then Throw New ArgumentException(ResourcesT.Exceptions.NumberOfItemsOf0DiffersFrom1.f("Data", "NumberOfComponents"))
            Dim Size As Integer = DirectoryEntry.BytesPerComponent(DataType) * NumberOfComponets
            Dim DataPosition As Integer
            If Size > 4 Then
                DataPosition = FindFreeSpace(Size)
                For i As Integer = DataPosition To DataPosition + Size - 1
                    WriterMap(i) = ReaderItemKinds.ExternalTagData
                Next
                If Map Is Nothing Then LastPosition = DataPosition + DataNormalized.Length
                Writer.Write(CUInt(DataPosition))
            Else
                DataPosition = Writer.BaseStream.Position
            End If
            Writer.Seek(DataPosition, IO.SeekOrigin.Begin)
            For Each item In DataNormalized
                Select Case DataType
                    Case ExifDataTypes.ASCII : Writer.Write(DirectCast(item, Char))
                    Case ExifDataTypes.Byte, ExifDataTypes.NA : Writer.Write(DirectCast(item, Byte))
                    Case ExifDataTypes.Double : Writer.Write(DirectCast(item, Double))
                    Case ExifDataTypes.Int16 : Writer.Write(DirectCast(item, Int16))
                    Case ExifDataTypes.Int32 : Writer.Write(DirectCast(item, Int32))
                    Case ExifDataTypes.SByte : Writer.Write(DirectCast(item, SByte))
                    Case ExifDataTypes.Single : Writer.Write(DirectCast(item, Single))
                    Case ExifDataTypes.SRational : Writer.Write(DirectCast(item, SRational).Numerator) : Writer.Write(DirectCast(item, SRational).Denominator)
                    Case ExifDataTypes.UInt16 : Writer.Write(DirectCast(item, UInt16))
                    Case ExifDataTypes.UInt32 : Writer.Write(DirectCast(item, UInt32))
                    Case ExifDataTypes.URational : Writer.Write(DirectCast(item, URational).Numerator) : Writer.Write(DirectCast(item, URational).Denominator)
                End Select
                If Size > 4 AndAlso Map Is Nothing Then LastPosition = Writer.BaseStream.Position
            Next item
            _RecordsWritten += 1
            If RecordsWritten >= RecordsToWrite Then _WriterState = WriterStates.General
            Return DataPosition
        End Function
        ''' <summary>Writes pointer BLOb to metadata stream</summary>
        ''' <param name="PointerOffset">Offset of pointer to BLOb. Offset of BLOb will be written here. It sould be value returned from <see cref="WriteRecord"/>.</param>
        ''' <param name="Blob">BLOb data</param>
        ''' <param name="BlobType">Type of BLOB reported to output stream. Only allowed values are <see cref="ReaderItemKinds.Unknown"/>, <see cref="ReaderItemKinds.JpegThumbnail"/> and <see cref="ReaderItemKinds.TiffThumbNail"/></param>
        ''' <param name="PointerSize">Defines data type of pointer</param>
        ''' <returns>Offset position where first byte of blob was written</returns>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="PointerSize"/> is not member of <see cref="PointerSizes"/> -or- <paramref name="BlobType"/> is not member of <see cref="ReaderItemKinds"/></exception>
        ''' <exception cref="ArgumentNullException"><paramref name="Blob"/> is null</exception>
        ''' <seealso cref="ArgumentException"><paramref name="BlobType"/> is none of <see cref="ReaderItemKinds.Unknown"/>, <see cref="ReaderItemKinds.JpegThumbnail"/> and <see cref="ReaderItemKinds.TiffThumbnailPart"/></seealso>
        ''' <exception cref="ArgumentOutOfRangeException"><paramref name="PointerOffset"/> is less than 4</exception>
        ''' <exception cref="OverflowException">Position of blob cannot be stored in value of type <paramref name="PointerSize"/></exception>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is <see cref="WriterStates.Beginning"/> or <see cref="writerstates.Finnished"/></exception>
        ''' <remarks>Pointer blob is some large block of binary data written in Exif stream. Great example is thumbnail image.</remarks>
        Public Function WritePointedBlob(ByVal PointerOffset As Integer, ByVal Blob As Byte(), ByVal BlobType As ReaderItemKinds, Optional ByVal PointerSize As PointerSizes = PointerSizes.UInt32) As Integer
            If WriterState = WriterStates.Beginning OrElse WriterState = WriterStates.Finnished Then Throw New InvalidOperationException(ResourcesT.Exceptions.WriterIsNotInitializedOrIsFinished)
            If Blob Is Nothing Then Throw New ArgumentNullException("Blob")
            If Blob.Length = 0 Then Throw New ArgumentException(ResourcesT.Exceptions.LengthOf0MustBeNonZero.f("Blob"))
            If Not InEnum(BlobType) Then Throw New InvalidEnumArgumentException("BlobType", BlobType, BlobType.GetType)
            Select Case BlobType
                Case ReaderItemKinds.Unknown, ReaderItemKinds.JpegThumbnail, ReaderItemKinds.TiffThumbnailPart
                Case Else : Throw New ArgumentException(ResourcesT.Exceptions.OnlyAllowedValuesForBlobTypeAreUnknownJpegThumbnailAndTiffThumbnailPart)
            End Select
            If PointerOffset < 4 Then Throw New ArgumentOutOfRangeException("PointerOffset", ResourcesT.Exceptions.MustBeEqualToOrGreaterThan1.f("PointerOffset", 4))
            If Not InEnum(PointerSize) Then Throw New InvalidEnumArgumentException("PointerSize", PointerSize, PointerSize.GetType)
            Dim Position = FindFreeSpace(Blob.Length)
            Writer.Seek(PointerOffset, IO.SeekOrigin.Begin)
            Select Case PointerSize
                Case PointerSizes.Byte : Writer.Write(CByte(Position))
                Case PointerSizes.UInt16 : Writer.Write(CUShort(Position))
                Case PointerSizes.UInt32 : Writer.Write(CUInt(Position))
            End Select
            Writer.Seek(Position, IO.SeekOrigin.Begin)
            Writer.Write(Blob)
            For i = Position To Position + Blob.Length - 1
                WriterMap(i) = BlobType
            Next
            If Map Is Nothing Then LastPosition = Position + Blob.Length
            Return Position
        End Function
        ''' <summary>Performs terminating operations and finnishes writing</summary>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is not <see cref="WriterStates.General"/></exception>
        Public Sub EndWriting()
            If WriterState <> WriterStates.General Then Throw New InvalidOperationException(ResourcesT.Exceptions.FinnishigIsNotAllowedInState0.f(WriterState))
            Dim LengthSet = False
            If Map IsNot Nothing Then
                For i As Integer = Map.Length - 1 To OutputMap.Length Step -1
                    If (Map(i) And ReaderItemKinds.WriterMask) OrElse Map(i) = ReaderItemKinds.Unknown OrElse (PreserveThumbnail AndAlso (Map(i) = ReaderItemKinds.JpegThumbnail OrElse Map(i) = ReaderItemKinds.TiffThumbnailPart)) Then
                        _Writer.BaseStream.SetLength(i + 1)
                        LengthSet = True
                        Exit For
                    End If
                Next
            End If
            If Not LengthSet Then _Writer.BaseStream.SetLength(OutputMap.Length)
            _WriterState = WriterStates.Finnished
            Writer.Flush()
            Writer.BaseStream.Flush()
        End Sub
#End Region
#Region "Helpers"
        ''' <summary>Converts Exif data to array type</summary>
        ''' <param name="Data">Data to be converted</param>
        ''' <param name="DataType">Type of data</param>
        ''' <returns>Array of items of given type, if <paramref name="Data"/> was of array of <paramref name="DataType"/> or <paramref name="DataType"/>; otherwise null</returns>
        Protected Shared Function NormalizeData(ByVal Data As Object, ByVal DataType As ExifDataTypes) As Array
            Select Case DataType
                Case ExifDataTypes.ASCII
                    If TypeOf Data Is Char() Then
                        Return Data
                    ElseIf TypeOf Data Is Char Then
                        Return New Char() {Data}
                    ElseIf TypeOf Data Is String Then
                        Return CType(DirectCast(Data, String), Char())
                    End If
                Case ExifDataTypes.Byte, ExifDataTypes.NA
                    If TypeOf Data Is Byte() Then
                        Return Data
                    ElseIf TypeOf Data Is Byte Then
                        Return New Byte() {Data}
                    End If
                Case ExifDataTypes.Double
                    If TypeOf Data Is Double() Then
                        Return Data
                    ElseIf TypeOf Data Is Double Then
                        Return New Double() {Data}
                    End If
                Case ExifDataTypes.Int16
                    If TypeOf Data Is Int16() Then
                        Return Data
                    ElseIf TypeOf Data Is Int16 Then
                        Return New Int16() {Data}
                    End If
                Case ExifDataTypes.Int32
                    If TypeOf Data Is Int32() Then
                        Return Data
                    ElseIf TypeOf Data Is Int32 Then
                        Return New Int32() {Data}
                    End If
                Case ExifDataTypes.SByte
                    If TypeOf Data Is SByte() Then
                        Return Data
                    ElseIf TypeOf Data Is SByte Then
                        Return New SByte() {Data}
                    End If
                Case ExifDataTypes.Single
                    If TypeOf Data Is Single() Then
                        Return Data
                    ElseIf TypeOf Data Is Single Then
                        Return New Single() {Data}
                    End If
                Case ExifDataTypes.SRational
                    If TypeOf Data Is SRational() Then
                        Return Data
                    ElseIf TypeOf Data Is SRational Then
                        Return New SRational() {Data}
                    End If
                Case ExifDataTypes.UInt16
                    If TypeOf Data Is UInt16() Then
                        Return Data
                    ElseIf TypeOf Data Is UInt16 Then
                        Return New UInt16() {Data}
                    End If
                Case ExifDataTypes.UInt32
                    If TypeOf Data Is UInt32() Then
                        Return Data
                    ElseIf TypeOf Data Is UInt32 Then
                        Return New UInt32() {Data}
                    End If
                Case ExifDataTypes.URational
                    If TypeOf Data Is URational() Then
                        Return Data
                    ElseIf TypeOf Data Is URational Then
                        Return New URational() {Data}
                    End If
            End Select
            Return Nothing
        End Function
        ''' <summary>If <see cref="Map"/> is null contains last written position in stream; otherwise contains offset of byte before first free byte in stream</summary>
        Private LastPosition As Integer
        ''' <summary>Gets offset of position where given number of bytes can be written</summary>
        ''' <param name="Size">Size of block (in bytes) to find space for</param>
        ''' <returns>Ofset of free block of size of <paramref name="Size"/> bytes</returns>
        ''' <remarks>The returned block may lay at the end of stream</remarks>
        Protected Overridable Function FindFreeSpace(ByVal Size As Integer) As Integer
            If Size < 0 Then Throw New ArgumentOutOfRangeException("Size", ResourcesT.Exceptions.MustBeGreaterThanOrEqualToZero.f("Size"))
            If Map IsNot Nothing Then
                Dim SpaceFound As Integer = -1
                Dim SpaceFoundAt As Integer = -1
                Dim FreeByteFound As Boolean = False
                For i As Integer = LastPosition To Map.Length - 1
                    If (Map(i) And ReaderItemKinds.WriterMask) <> ReaderItemKinds.WriterMask AndAlso Map(i) <> ReaderItemKinds.Unknown AndAlso (Not PreserveThumbnail OrElse (Map(i) <> ReaderItemKinds.JpegThumbnail AndAlso Map(i) <> ReaderItemKinds.TiffThumbnailPart)) Then
                        FreeByteFound = True
                        If SpaceFound < 0 Then SpaceFoundAt = i : SpaceFound = 1 Else SpaceFound += 1
                        If SpaceFound = Size Then Return SpaceFoundAt
                    Else
                        SpaceFound = -1
                        SpaceFoundAt = -1
                        If Not FreeByteFound Then
                            LastPosition = i
                        End If
                    End If
                Next
                Return Writer.BaseStream.Length
            Else
                Return LastPosition
            End If
        End Function
        ''' <summary>Contains value of the <see cref="RecordsToWrite"/> property</summary>
        Private _RecordsToWrite%
        ''' <summary>Gets number of records to be written when <see cref="WriterState"/> is <see cref="WriterStates.Records"/></summary>
        ''' <returns>When <see cref="writerstate"/> is <see cref="WriterStates.Records"/> total number of records to be written; otherwise return value is meaningless.</returns>
        Protected ReadOnly Property RecordsToWrite%()
            Get
                Return _RecordsToWrite
            End Get
        End Property
        ''' <summary>Contains value of the <see cref="RecordsWritten"/> property</summary>
        Private _RecordsWritten%
        ''' <summary>Gets number of records (of total) <see cref="RecordsToWrite"/> written when <see cref="WriterState"/> is <see cref="WriterStates.Records"/></summary>
        ''' <returns>When <see cref="WriterState"/> is <see cref="WriterStates.Records"/> gets number of records (of total <see cref="RecordsToWrite"/>) that was already written to current IFD; otherwise is meaningless.</returns>
        Protected ReadOnly Property RecordsWritten%()
            Get
                Return _RecordsWritten
            End Get
        End Property
        ''' <summary>Contains value of the <see cref="FirstRecordOffset"/> property</summary>
        Private _FirstRecordOffset%
        ''' <summary>Gets offset of first record when <see cref="WriterState"/> is <see cref="WriterStates.Records"/></summary>
        ''' <returns>When <see cref="WriterState"/> is <see cref="WriterStates.Records"/> gets offset (in bytes, from bebinning) to firs record of IFD currently being written; otherwise is meaningless</returns>
        Protected ReadOnly Property FirstRecordOffset%()
            Get
                Return _FirstRecordOffset
            End Get
        End Property
        ''' <summary>Supportede datatypes for pointers in Exif stream</summary>
        ''' <remarks>Values of items are same as values of corresponding items in <see cref="ExifDataTypes"/></remarks>
        ''' <seealso cref="ExifDataTypes"/>
        Public Enum PointerSizes
            ''' <summary>1-byte (8-bits) unsigned integer</summary>
            [Byte] = ExifDataTypes.Byte
            ''' <summary>2-bytes (16-bits) unsigned integer</summary>
            UInt16 = ExifDataTypes.UInt16
            ''' <summary>4-bytes (32-bits) unsigned integer</summary>
            UInt32 = ExifDataTypes.UInt32
        End Enum
        ''' <summary>Gets or sets state of byte at given index in map</summary>
        ''' <param name="Index">Index in map. If index is out of range, it is allocated in output map, not in input one.</param>
        ''' <value>Value to be written. Values are always or-ed with <see cref="ReaderItemKinds.WriterMask"/> before writing</value>
        ''' <returns>Current value form output map at given index. Or <see cref="ReaderItemKinds.Empty"/> if <paramref name="Index"/> is out of rangte of output map.</returns>
        Protected Property WriterMap(ByVal Index As Integer) As ReaderItemKinds
            Set(ByVal value As ReaderItemKinds)
                If Index < 0 Then Throw New ArgumentOutOfRangeException("Index", ResourcesT.Exceptions.MustBeGreaterThanOrEqualToZero)
                If Map IsNot Nothing AndAlso Index < Map.Length Then Map(Index) = value Or ReaderItemKinds.WriterMask
                While Index >= NewMap.Count
                    NewMap.Add(ReaderItemKinds.Unknown)
                End While
                NewMap(Index) = value
            End Set
            Get
                If Index < 0 Then Throw New ArgumentOutOfRangeException("Index", ResourcesT.Exceptions.MustBeGreaterThanOrEqualToZero)
                If Index < NewMap.Count Then Return NewMap(Index)
                Return ReaderItemKinds.Empty
            End Get
        End Property
        ''' <summary>Gets current number of valid items in <see cref="WriterMap"/></summary>
        Protected ReadOnly Property WriterMapLenght() As Integer
            Get
                Return NewMap.Count
            End Get
        End Property
#End Region
#Region "Shared"
#End Region
        ''' <summary>Delegate used as callback function by <see cref="Save"/> method whenever record is written to stream</summary>
        ''' <param name="Sender">Instance of <see cref="ExifWriter"/> that called the callback</param>
        ''' <param name="Ifd"><see cref="Ifd"/> record belongs to. This can be <see cref="SubIfd"/>.</param>
        ''' <param name="RecordTag">Number of record tag</param>
        ''' <param name="RecordData">Record data that have benn written.</param>
        ''' <param name="DataOffset">Offset in stream where recor data have been written</param>
        ''' <remarks>You can use this delegate to write BLOb data (<see cref="WritePointedBlob"/> to record).
        ''' <para>This delegate is not CLS-compliant. There is <see cref="RecordWrittenCallbackCls"/> which is CLS-compliant.</para></remarks>
        <CLSCompliant(False)> _
        Public Delegate Sub RecordWrittenCallback(ByVal Sender As ExifWriter, ByVal Ifd As Ifd, ByVal RecordTag As UShort, ByVal RecordData As ExifRecord, ByVal DataOffset As Integer)
        ''' <summary>Delegate used as callback function by <see cref="Save"/> method whenever record is written to stream (CLS-compliant)</summary>
        ''' <param name="Sender">Instance of <see cref="ExifWriter"/> that called the callback</param>
        ''' <param name="Ifd"><see cref="Ifd"/> record belongs to. This can be <see cref="SubIfd"/>.</param>
        ''' <param name="RecordTag">Number of record tag (values are in range of <see cref="UShort"/> type)</param>
        ''' <param name="RecordData">Record data that have benn written.</param>
        ''' <param name="DataOffset">Offset in stream where recor data have been written</param>
        ''' <remarks>You can use this delegate to write BLOb data (<see cref="WritePointedBlob"/> to record).</remarks>
        Public Delegate Sub RecordWrittenCallbackCls(ByVal Sender As ExifWriter, ByVal Ifd As Ifd, ByVal RecordTag As Integer, ByVal RecordData As ExifRecord, ByVal DataOffset As Integer)
        ''' <summary>Saves all the exif data from given <see cref="Exif"/></summary>
        ''' <remarks>This method is not CLS-compliant, but there is CLS-compilant overload.
        ''' <para>This function calls <see cref="EndWriting"/> when all data are written.</para>
        ''' <para>Thumbnail behavior of this function depends on <see cref="PreserveThumbnail"/>. This function alone is not capable of writing thumbnail, use <paramref name="RecordWrittenCallback"/> to write thumbnail data as pointed BLOb.</para></remarks>
        ''' <param name="Data"><see cref="Exif"/> to save</param>
        ''' <param name="RecordWrittenCallback">Optional callback function called whenever record is written</param>
        ''' <exception cref="ArgumentNullException"><paramref name="Data"/> is null -or- Data stored in any record are null.</exception>
        ''' <exception cref="InvalidEnumArgumentException">Any <see cref="Ifd"/> contains pointer to SubIFD and data type of the pointer is not one of <see cref="PointerSizes"/>. -or- Record of unsupported datatype reached.</exception>
        ''' <exception cref="ArgumentException">Any <see cref="Ifd"/> contains pointer to SubIFD and data type of the pointer has multiple components. -or- <see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.NumberOfElements">NumberOfElements</see> of any record differes from number of components in <see cref="ExifRecord.Data"/></exception>
        ''' <exception cref="TypeMismatchException"><see cref="ExifRecord.Data"/> of any record is of different type than is reported by <see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.DataType">DataType</see></exception>
        ''' <version version="1.5.2">Method introduced</version>
        <CLSCompliant(False)> _
        Public Sub Save(ByVal Data As Exif, Optional ByVal RecordWrittenCallback As RecordWrittenCallback = Nothing)
            If Data Is Nothing Then Throw New ArgumentNullException("Data")
            Dim IfdPointerOffset = WriteHeader()
            Dim Ifd As Ifd = Data.IFD0
            While Ifd IsNot Nothing
                IfdPointerOffset = AllocateIfd(IfdPointerOffset, Ifd.Records.Count)
                SaveIfdRecords(Ifd)
                Ifd = Ifd.Following
            End While
            EndWriting()
        End Sub
        ''' <summary>Saves all the exif data from given <see cref="Exif"/> (CLS compliant)</summary>
        ''' <param name="Data"><see cref="Exif"/> to save</param>
        ''' <param name="RecordWrittenCallback">Optional callback function called whenever record is written</param>
        ''' <exception cref="ArgumentNullException"><paramref name="Data"/> is null -or- Data stored in any rord are null.</exception>
        ''' <exception cref="InvalidEnumArgumentException">Any <see cref="Ifd"/> contains pointer to SubIFD and data type of the pointer is not one of <see cref="PointerSizes"/>. -or- Record of unsupported datatype reached.</exception>
        ''' <exception cref="ArgumentException">Any <see cref="Ifd"/> contains pointer to SubIFD and data type of the pointer has multiple components. -or- <see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.NumberOfElements">NumberOfElements</see> of any record differes from number of components in <see cref="ExifRecord.Data"/></exception>
        ''' <exception cref="TypeMismatchException"><see cref="ExifRecord.Data"/> of any record is of different type than is reported by <see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.DataType">DataType</see></exception>
        ''' <remarks><para>This function calls <see cref="EndWriting"/> when all data are written.</para>
        ''' <para>Thumbnail behavior of this function depends on <see cref="PreserveThumbnail"/>. This function alone is not capable of writing thumbnail, use <paramref name="RecordWrittenCallback"/> to write thumbnail data as pointed BLOb.</para></remarks>
        ''' <version version="1.5.2">Method introduced</version>
        Public Sub Save(ByVal Data As Exif, ByVal RecordWrittenCallback As RecordWrittenCallbackCls)
            If RecordWrittenCallback Is Nothing Then
                Save(Data)
            Else
                Save(Data, New RecordWrittenCallback(AddressOf RecordWrittenCallback.Invoke)) 'TODO: Does it work?
            End If
        End Sub
        ''' <summary>Save all records of one IFD. If IFD contains SubIFDs thay are saved too.</summary>
        ''' <param name="Ifd">Ifd to save records of. There must be prealocated space for records using <see cref="AllocateIfd"/>.</param>
        ''' <exception cref="InvalidEnumArgumentException"><paramref name="Ifd"/> contains pointer to SubIFD and data type of the pointer is not one of <see cref="PointerSizes"/>. -or- Record of unsupported datatype reached.</exception>
        ''' <exception cref="ArgumentException"><paramref name="Ifd"/> contains pointer to SubIFD and data type of the pointer has multiple components.</exception>
        ''' <exception cref="ArgumentNullException"><paramref name="Ifd"/> is null -or- data stored in any rord are null.</exception>
        ''' <exception cref="InvalidOperationException"><see cref="WriterState"/> is not <see cref="WriterStates.Records"/> or all records have been already written -or- Not enought space for al records ahve been allocated.</exception>
        ''' <exception cref="TypeMismatchException"><see cref="ExifRecord.Data"/> of any record is of different type then is reported by <see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.DataType">DataType</see></exception>
        ''' <exception cref="ArgumentException"><see cref="ExifRecord.DataType"/>.<see cref="ExifRecordDescription.NumberOfElements">NumberOfElements</see> of any record differes from number of components in <see cref="ExifRecord.Data"/></exception>
        Private Sub SaveIfdRecords(ByVal Ifd As Ifd, Optional ByVal RecordWrittenCallback As RecordWrittenCallback = Nothing)
            If Ifd Is Nothing Then Throw New ArgumentNullException("Ifd")
            Dim SubIFDPointerOffsets As New Dictionary(Of UShort, Integer)
            For Each Rec In Ifd.Records
                Dim DataOffset = WriteRecord(Rec.Key, Rec.Value)
                If Ifd.SubIFDs.ContainsKey(Rec.Key) Then SubIFDPointerOffsets.Add(Rec.Key, DataOffset)
                If RecordWrittenCallback IsNot Nothing Then RecordWrittenCallback.Invoke(Me, Ifd, Rec.Key, Rec.Value, DataOffset)
            Next
            For Each SubIfd In Ifd.SubIFDs
                If Ifd.Records(SubIfd.Key).DataType.NumberOfElements <> 1 Then _
                    Throw New ArgumentException(ResourcesT.Exceptions.IFDBeingSavedIsInvalidPointerToSubIFDMustHaveOneComponent)
                Dim NextIfdPointer = AllocateIfd(SubIFDPointerOffsets(SubIfd.Key), SubIfd.Value.Records.Count, True, Ifd.Records(SubIfd.Key).DataType.DataType)
                Dim NextSubIfd As Ifd = SubIfd.Value
                While NextSubIfd IsNot Nothing
                    SaveIfdRecords(NextSubIfd)
                    NextSubIfd = NextSubIfd.Following
                    If NextSubIfd IsNot Nothing Then _
                        NextIfdPointer = AllocateIfd(NextIfdPointer, NextSubIfd.Records.Count)
                End While
            Next
        End Sub
    End Class
End Namespace

#End If
